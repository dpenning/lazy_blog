Input actions will be the same as a hover effects, we will have actions that are assigned after the first actionable item has been hit by the mouse. There will be an InputController singleton what handles all of the actions

```zig

```

Once the hit test has been performed we can set a closure on the input controller. We will store a bunch of button state information in 

```zig
const ButtonState = struct {
    just_clicked: bool = false,
    currently_held_down: bool = false,
    just_released: bool = false,
    released_action: ?InputAction = null,
    immediate_action: ?InputAction = null,
};
```

There will be several input actions that can be assigned (all defined by the mouse definitions in raylib). These will have a closure assigned within them

```zig
left: ButtonState = .{},
right: ButtonState = .{},
middle: ButtonState = .{},
side: ButtonState = .{},
extra: ButtonState = .{},
forward: ButtonState = .{},
back: ButtonState = .{},
```

We can create a mapping for use in comptime inline forloop so that we can perform the same updates for each of the button states

```
const button_id_field_mapping = [_]struct {
    id: c_int,
    name: []const u8,
}{
    .{ .id = rl.MOUSE_BUTTON_LEFT, .name = "left" },
    .{ .id = rl.MOUSE_BUTTON_RIGHT, .name = "right" },
    .{ .id = rl.MOUSE_BUTTON_MIDDLE, .name = "middle" },
    .{ .id = rl.MOUSE_BUTTON_SIDE, .name = "side" },
    .{ .id = rl.MOUSE_BUTTON_EXTRA, .name = "extra" },
    .{ .id = rl.MOUSE_BUTTON_FORWARD, .name = "forward" },
    .{ .id = rl.MOUSE_BUTTON_BACK, .name = "back" },
};
```

and then we can build our ButtonState each frame from this

```zig
// Called via the Runloop. This is called before hover is calculated.
pub fn update(self: *Self) void {
    // ...

    // Iterate through the mouse button states updating them.
    inline for (&button_id_field_mapping) |*button_id_field| {
        var state = &@field(self.*, button_id_field.name);

        // Read both the pressed state and the down state just to be super sure.
        const is_button_held_down =
            rl.IsMouseButtonPressed(button_id_field.id) or
            rl.IsMouseButtonDown(button_id_field.id);

        const is_button_just_clicked =
            is_button_held_down and !state.currently_held_down;

        const is_button_just_released =
            !is_button_held_down and
            state.currently_held_down;

        state.just_clicked = is_button_just_clicked;
        state.currently_held_down = is_button_held_down;
        state.just_released = is_button_just_released;
    }
}
```

This is similar to raylib implementation but I'm keeping track of my own version of what raylibs implementation for mouse clicking is so that i have more control over the design in case i need to change it.

Running the actions is similarly inlined so that code is shared for each of the fields

```zig
pub fn runActions(self: *Self) void {
    inline for (&button_id_field_mapping) |*button_id_field| {
        var state = &@field(self, button_id_field.name);
        if (state.immediate_action) |*immediate_action| {
            if (state.just_clicked) {
                immediate_action.call(immediate_action.ctx);
            }
        }

        if (state.released_action) |*released_action| {
            if (state.just_released) {
                released_action.call(released_action.ctx);
            }
        }
    }
}
```

This should eventually extend to the gamepad implementation as well, however its values wont be updated by the mouse position and instead will have some focus ording system
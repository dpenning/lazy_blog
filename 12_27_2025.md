I was attempting to design the game elements, however i ran into some confusion as I started to plot out how the game will represent the objects and actions that occur. So i spent some time thinking about what the right way to represent the game state will be.

To start I will have
- Individual players.
- Turns that occur in multiple rounds until the game is complete.
- A hex grid of tiles referred to as the board.
- Objects that exist on the board.
- Actions that can be taken to modify the objects or the tiles.
- A scoring system.

the first couple points are easy enough to represent

```zig
const Player = struct { ... };
const Tile = struct { ... };
const Board = struct {
    width: usize,
    height: usize,
    tiles: []Tiles,
    objects: []Objects,
};

const GameState = struct {
    players: [3]Player,
    current_player: usize,

    current_round: usize,
    board: Board,
}
```

however i quickly ran into some issues with this design when i started to consider how events that depended on when they were played would occur. for instance if we introduce our first mechanic of actions that take place on a tile we now need to place some state on the tile object, lets use an example of a smoke effect.


One way we could represent this smoke effect is by having a smoke boolean,
```zig
const Tile = struct {
    smoke: boolean
}
```

But what if the smoke effect would take place only for a specific amount of time? We could represent this as an int of number of turns left (we might also need the player who played it) and then we would update this on turn.
```zig
const Tile = struct {
    smokeTimeLeft: uint,
}
```

But what if we have to deal with potentially multiple actions creating a smoke effect? we could represent this as an action that affected this tile and what attributes it added.
```zig
const Tile = struct {
    affectingActions: []struct {
        action_handle: uint,
        property_added: <property_id>,
    }
}
```

This could be a good way to do some tracking of the state across turns, but theres a lot of book keeping going on. Of the options my preference would be the 3rd but this does require stroing a bunch of extra information and doing a bunch of lookups. instead i think the first is the best, with the caveat of adding some extra book keeping on the side.

This would look like storing a list of events in a history, as part of the gamestate, and then using that to construct the game information.

```zig

const ActionKind = union(enum) {
    AddSmoke: struct {
        position: Position,
    },
    ...
};

const Action = struct {
    player: usize,
    turn: usize,
    kind: ActionKind,
};

const ActionHistory = {
    init (alloc) {...}
    add (action: Action) {}
    pop(): Action {}

    actions: []TurnAction,
}

const GameState = struct {
    board: Board,
    actions: ActionHistory,
    ...

    performAction() { ... }
    undoLastAction() { ... }
}
```

and then the tiles can just represent the current state (back to just being a boolean)

https://martinfowler.com/eaaDev/EventSourcing.html

The idea for separating events that mutate the state from the state itself was discussed by martin fowler in the article above, in there he discusses many reasons for want to keep a list of events, and then using an event processor to update the state. Some reasons for this are similar to what im looking to achieve which include undo, rebuilding the state, snapshotting.
While starting on a simple Raylib turnbased boardgame, i decided to start with how to paint a UI to the screen to interact with the window. Im going to add a way to implement the HUD of the game and menus.

This will be referred to as a "Layout"

The layout will have in it all of the objects that need to be painted as lists of objects. so far we will need multiple types of menus and the game HUD.

menus will have
- A background
- buttons
- Header Text
- Text Inputs
- Sliders
- Number Inputs

```
-------------------------------------------
|              Background                 |
|                 Title Text              |
|                  [button]               |
|                  [button]               |
|                  [button]               |
|                                         |
|                 Section Text            |
|                  [button]               |
|                  [button]               |
|                  [button]               |
-------------------------------------------
```

the HUD will have
- some announcement of whos turn it is at the top of the screen
- the cards on the bottom of the screen
- a settings button which will show the menu
- some list of actions that occured on the right side
- some scoring indicator
- some stats for the player to take into consideration

```
----------------------------------------------
|  Score          your turn                X |
|                                            |
|                                            |
|                                          L |
|                   Game                   L |
|                     Board                L |
|                                          L |
|                                            |
|                                            |
|   Stats                             Stats  |
|   Stats          [ Cards ]          Stats  |
----------------------------------------------
```

The UI class will have a list of Layouts. It will have ALL of these components in lists and will iterate through them in order to paint them. It will also be used with mouse position to pick the element that is going to consume the mouse click/hover.

```
PSUEDOCODE

Components
  bool reactToMouseHover(bool already_hovered)
  void paintToWindow()

Layout
  background
  buttons
  text_inputs
  number_inputs
  slider_inputs
  labels
  stats
  scores
  cards
  game_board
  action_history
  
  bool reactToMouseHover(bool already_hovered)
    for all components
        for all components lists: list_item
            if (reactToMouseHover(already_hovered))
                already_hovered = true
    return already_hovered;

  void paintToWindow()
    for all components
        for all components lists: list_item
            paintToWindow(list_item)
```

this is pretty cumbersome but with zig we can at least make this a bit cleaner to implement.

we can create a components struct that will have slices of all of the components we want to paint...
```zig
const Components = struct {
    const Self = @This();
    backgrounds: []const Background,
    buttons: []const Button,
    text_inputs: []const TextInputs,
    // ...

    pub fn paintToWindow(self: *const Self, window: *Window) void {
        inline for (std.meta.fields(Self)) |f| {
            const slice = @field(self, f.name);

            for (slice) |*item| item.paintToWindow()
        }
    }
};
```zig
and then use that within our layout class

```zig
const Layout = struct {
  components: Components,

  paintToWindow(self: *const Self, window: *Window) {
    components.paintToWindow(window);
  }
}
```

This can be done for every function we need to recursively pass down through the components. This could have been done with C and macros

```C
typedef struct { /* ... */ } Button;
typedef struct { /* ... */ } Slider;

void Button_render(const Button* b) { /* ... */ }
void Slider_render(const Slider* s) { /* ... */ }

// name, type, render_fn
#define COMPONENT_LIST(X) \
    X(buttons, Button, Button_render) \
    X(sliders, Slider, Slider_render)

typedef struct {
#define DECL_FIELD(name, T, render_fn) \
    const T* name; \
    size_t name##_len;

    COMPONENT_LIST(DECL_FIELD)
#undef DECL_FIELD
} Components;


static inline void Components_render(const Components* c) {
#define RENDER_FIELD(name, T, render_fn)                 \
    for (size_t i = 0; i < c->name##_len; i++) {        \
        render_fn(&c->name[i]);                         \
    }

    COMPONENT_LIST(RENDER_FIELD)
#undef RENDER_FIELD
}

typedef struct {
    Components components;
} Layout;

static inline void Layout_render(const Layout* l) {
    Components_render(&l->components);
}
```

but this still feels a lot harder to understand than the corresponding zig.
Now have some way to display components in a
  configuration, we can create a menu. The menu will
  be a list of buttons with a background that is
  centered in the screen.

The position/size of the menu buttons should be
based on the window size. This means we will need
to be able to read and react to the window size
changing.

The plan is that we will have a Layout object that
represents the menu, that will have the background,
and the buttons. then, any time the window size
updates, we will update all of the components in the
menu with new positions.

```zig
var main_menu_backgrounds = [_]Background{ default_background };

var main_menu_buttons = [_]Button{
    .{ .label = "Start Game" },
    .{ .label = "Exit" },
};

pub var main_menu = Layout{
    .components = .{
        .backgrounds = &main_menu_backgrounds,
        .buttons = &main_menu_buttons,
    },
    .updateLayoutFromWindow = UpdateMenuFromWindow,
};
```

We can read the size information for the window via
IsWindowResized. This must be polled, so we will
introduce this as part of the Window. I would also
like to keep the menus as variables that are not
recreated every frame OR whenever theres an update
so the plan will be to take a menu as a ptr, and
then manipulate its buttons and background as a
result. For this purpose we will just take a Layout
object and not make a "Menu" so that we dont have to
do anything else with the type system but that might
need to be revisited later.

```zig
const Size = struct {
    width: u32,
    height: u32,
};

pub fn UpdateMenuFromWindow(
    menu: *Layout,
    window: *const Window,
) void {
    _ = window;

    const screen_size = Size{
        .width = @as(u32, @intCast(rl.GetScreenWidth())),
        .height = @as(u32, @intCast(rl.GetScreenHeight())),
    };

    const third_screen_width = screen_size.width / 3;

    var background_size = Size{
        .width = @max(MIN_BACKGROUND_WIDTH, third_screen_width),
        .height = screen_size.height,
    };

    if (background_size.width % 2 != screen_size.width % 2) {
        background_size.width -= 1;
    }

    const screen_width_i32: i32 =
        @intCast(screen_size.width);
    const background_width_i32: i32 =
        @intCast(background_size.width);
    const background_height_i32: i32 =
        @intCast(background_size.height);

    const background_x =
        @divTrunc(
            screen_width_i32 - background_width_i32,
            @as(i32, 2),
        );

    for (menu.components.backgrounds) |*background| {
        background.x = background_x;
        background.y = 0;
        background.width = background_width_i32;
        background.height = background_height_i32;
    }

    // ...
}
```

  Our menus will have a width for the buttons, and
  then a min size for the background.
  For now im going to make the Background 33% of the
  screen, positioned in the center.
  in order to position in the center, if the screen
  width is odd, then the background will be odd as
  well.
  The buttons will need to fit vertically in the
  menu as well, for now the menu will extend the full
  height of the screen.

  The buttons will be positioned descending on the
  menu, and will be centered horizontally within the
  background. If the width of the background is odd,
  the width of the buttons will be odd and visa versa
  so that the buttons are exactly centered. the text
  will not be centered in the button, we could always
  change that within the button implementation though
  with MeasureTextEx.

```zig
pub fn UpdateMenuFromWindow(
    menu: *Layout,
    window: *const Window,
) void {
    // ...

    var button_width = MENU_BUTTON_SIZE.width;
    if (button_width % 2 != background_size.width % 2) {
        button_width -= 1;
    }

    const button_width_i32: i32 =
        @intCast(button_width);
    const button_height_i32: i32 =
        @intCast(MENU_BUTTON_SIZE.height);

    const button_x =
        background_x +
        @divTrunc(
            background_width_i32 - button_width_i32,
            @as(i32, 2),
        );

    var button_y: i32 = MENU_BACKGROUND_MIN_PADDING;

    for (menu.components.buttons) |*button| {
        button.x = button_x;
        button.y = button_y;
        button.width = button_width_i32;
        button.height = button_height_i32;

        button_y +=
            button.height +
            MENU_BACKGROUND_MIN_PADDING;
    }
}
```

Now that the layout is alive, we also need to know
where the mouse is and which component (if any)
should react. The plan is simple: keep the mouse
position in an InputController, update it every
frame, and have the UI walk components from front to
back so the top-most element claims hover first.

The input controller will be shared for many different functions like handling keyboard, mouse, and controller inputs in the future but for now just mouse events.
```zig
const InputController = struct {
    mouse_x: f32 = 0,
    mouse_y: f32 = 0,

    pub fn update(self: *InputController) void {
        const pos = rl.GetMousePosition();
        self.mouse_x = pos.x;
        self.mouse_y = pos.y;
    }
};
```

The run loop owns one controller instance, updates
it alongside the window/layout refresh, and hands
its coordinates to the UI hover pass:

```zig
// ... runloop
ui.updateLayoutsForWindow(window);
input_controller.update();
_ = ui.updateHoverForMousePosition(
    false,
    input_controller.mouse_x,
    input_controller.mouse_y,
);

while (!rl.WindowShouldClose()) {
    if (rl.IsWindowResized()) {
        window.width =
            @intCast(rl.GetScreenWidth());
        window.height =
            @intCast(rl.GetScreenHeight());
        ui.updateLayoutsForWindow(window);
    }

    input_controller.update();
    _ = ui.updateHoverForMousePosition(
        false,
        input_controller.mouse_x,
        input_controller.mouse_y,
    );

    // draw...
}
```

updateHoverForMousePosition walks the layout stack top-down, threading a bool already_hovered flag so once a component reports true we stop letting lower layers grab the hover.
The button component is where the actual behavior lives: it compares the mouse rect with its bounds, flips its hovered flag, and tweaks colors in paint. 

```zig
pub fn updateHoverForMousePosition(
    self: *Self,
    already_hovered: bool,
    mouse_x: f32,
    mouse_y: f32,
) bool {
    if (already_hovered) {
        if (self.hovered) self.hovered = false;
        return true;
    }

    const min_x = @as(f32, @floatFromInt(self.x));
    const max_x =
        min_x +
        @as(f32, @floatFromInt(self.width));

    const min_y = @as(f32, @floatFromInt(self.y));
    const max_y =
        min_y +
        @as(f32, @floatFromInt(self.height));

    const inside =
        mouse_x >= min_x and mouse_x <= max_x and
        mouse_y >= min_y and mouse_y <= max_y;

    self.hovered = inside;
    return inside;
}

pub fn paint(self: *const Self) void {
    const rect_color =
        if (self.hovered)
            rl.LIGHTGRAY
        else
            rl.DARKGRAY;

    const label_color =
        if (self.hovered)
            rl.BLACK
        else
            rl.RAYWHITE;

    // draw rectangle + text...
}
```

The coolest part is how the Components struct fans out to each component slice. The updateHoverForMousePosition method uses std.meta.fields(Self) plus @hasDecl to decide, at comptime, whether a concrete component type even exposes that method.
Backgrounds for instance don’t care about hover, so they never have to implement a no-op, there simply isn’t a symbol to call, and the compiler removes the branch entirely.

```zig
pub fn updateHoverForMousePosition(
    self: *Self,
    already_hovered: bool,
    mouse_x: f32,
    mouse_y: f32,
) bool {
    var hovered = already_hovered;
    const fields = std.meta.fields(Self);

    comptime var field_index = fields.len;
    inline while (field_index > 0) : (field_index -= 1) {
        const field = fields[field_index - 1];
        var items = @field(self, field.name);

        var item_index: usize = items.len;
        while (item_index > 0) {
            item_index -= 1;
            var item = &items[item_index];

            if (@hasDecl(
                @TypeOf(item.*),
                "updateHoverForMousePosition",
            )) {
                hovered =
                    item.updateHoverForMousePosition(
                        hovered,
                        mouse_x,
                        mouse_y,
                    );
            }
        }
    }

    return hovered;
}
```

Because the loops are inline, the compiler generates calls only for the component types that actually implement hover. Backgrounds for instance get skipped entirely, buttons run their logic, and we never allocate or inspect vtables at runtime. Im not sure how you would implement something like this in C. Its possible to implement something like this in C++20+ with concepts however again zig is way cleaner here...

```C++
template <typename T>
concept Hoverable =
    requires(T& item, bool hovered, float x, float y) {
        {
            item.updateHoverForMousePosition(hovered, x, y)
        } -> std::same_as<bool>;
    };

template <typename ComponentList>
bool updateHoverForMousePosition(
    ComponentList& items,
    bool already_hovered,
    float mouse_x,
    float mouse_y
) {
    bool hovered = already_hovered;

    for (auto it = items.rbegin(); it != items.rend(); ++it) {
        if constexpr (
            Hoverable<std::remove_reference_t<decltype(*it)>>
        ) {
            hovered =
                it->updateHoverForMousePosition(
                    hovered,
                    mouse_x,
                    mouse_y
                );
        }
    }

    return hovered;
}
```